---
title: "sub-code-partC"
author: "Anshuman"
date: "1/19/2020"
output: html_document
---

```{r}
#loop through each fine time scale chunk
for(group in c(1:length(ts))){
  
#generate a count matrix for current group
mat = matrix(0,0,length(unique(Count_data$Taxon)))

#start and end depth of the group
start = ranges[ts,1]
end = ranges[ts,2]

#extract counts in chunks of 30cm
for(i in seq(start,(end-0.4),0.4)){
  r = rep(0,no_of_taxa); names(r) = unique(Count_data$Taxon)
  for(j in seq(i,i+0.3,0.1)){
    idx = which(depth == j)
    r[Count_data$Taxon[idx]] = r[Count_data$Taxon[idx]] + Count_data$count[idx]
  }
  mat = rbind(mat,r)
}


#generate pseudo-counts by random bootstrap process, 1000 iterations
bootstrap = sapply(seq(1000), function(i){
  null = t(apply(mat,1,function(x) {
    #obtain rl string for the stratum
    rlstr = c()
    new_count = rep(0,ncol(mat)); names(new_count) = unique(Count_data$Taxon)
    for(count in x){
      if(count > 0){
        idx = which(x == count)
        rlstr = c(rlstr,rep(unique(Count_data$Taxon)[idx],count))
      }
    }
    #sanity check: see if any fossils exist at this level
    if(length(rlstr) > 0){
      #perform a sample with replacement
      rlstr = sample(rlstr,replace = T)
      counts = table(rlstr)
      new_count[names(counts)] = counts
      return(as.numeric(new_count))
    }
    else{
      return(x)
    }
  }))
  #obtain fossil co-abundance adjacency matrix based on pseudo counts
  cc = suppressWarnings(cor(null))
  
  #set diagnals of the matrix to 0
  diag(cc) = 0
  
  #return adjacency matrix flattened as a vector
  return(as.vector(cc))
})

corr_mats[[group]] = matrix(rowMeans(bootstrap),nrow = no_of_taxa,ncol = no_of_taxa)

rownames(corr_mats[[group]])<- unique(Count_data$Taxon)
colnames(corr_mats[[group]])<- unique(Count_data$Taxon)

#print the mean correlations between taxa obtained after the bootstrap process
print(lattice::levelplot(corr_mats[[group]], scales=list(x = list(cex = .3,rot = 90),y = list(cex=.3)), at = seq(-1,1,0.1),colorkey = list(col = colorRampPalette(c("blue","white","red"))),col.regions = colorRampPalette(c("blue","white","red"))))

corr_mats[[group]][!is.finite(corr_mats[[group]])] <- 0

amat= corr_mats[[group]]
zmat <- matrix(0, ncol = nrow(corr_mats[[group]]), nrow = nrow(corr_mats[[group]]))
pmat <- matrix(0, ncol = nrow(corr_mats[[group]]), nrow = nrow(corr_mats[[group]]))

n <- ncol(corr_mats[[group]])
for (i in 1:nrow(corr_mats[[group]])) {
  for (j in i:nrow(corr_mats[[group]])) {
    zmat[i, j] <- atanh(corr_mats[[group]][i, j])
    zmat[j, i] <- zmat[i, j]
    pmat[i, j] <- 2 * pnorm(abs(zmat[i, j]), 0, sqrt(1/(n-3)), lower.tail=FALSE)
    pmat[j, i] <- pmat[i, j]
  }
}


n <- length(pmat)
pcorrmat <- matrix(0, dim(amat)[1], dim(amat)[2])
for(i in 1:nrow(amat)){ 
  for(j in 1:nrow(amat)){
    rowi <- amat[i, -c(i, j)]
    rowj <- amat[j, -c(i, j)] 
    tmp <- (amat[i, j] - rowi * rowj) / sqrt((1 - rowi^2) * (1 - rowj^2)) 
    tmp.zvals <- (0.5) * log((1 + tmp) / (1 - tmp)) 
    tmp.s.zvals <- sqrt(n - 1 - 3) * tmp.zvals 
    tmp.pvals <- 2 * pnorm(abs(tmp.s.zvals), 0, 1, lower.tail = FALSE) 
    pcorrmat[i, j] <- max(tmp.pvals)
  } 
}

pcorradjmat_BH <- matrix(p.adjust(pcorrmat, method = "BH", n = length(pcorrmat)), nrow = nrow(corr_mats[[group]]), ncol = nrow(corr_mats[[group]]))

pcorr_graph_BH <- matrix(as.numeric(pcorradjmat_BH < 0.01), nrow = nrow(corr_mats[[group]]), ncol = nrow(corr_mats[[group]]))

comm_mats[[group]]=pcorr_graph_BH
#comm_mats[[group]] = matrix(rmTest(rowMeans(bootstrap)),nrow = no_of_taxa,ncol = no_of_taxa)
#comm_mats[[group]] <- ceiling(0.5 * (comm_mats[[group]] + t(comm_mats[[group]])))
graphRM <- graph_from_adjacency_matrix(comm_mats[[group]], mode = "undirected", weighted = NULL, diag = TRUE, add.colnames = NULL, add.rownames = NA)

graph_list_org[[group]]=graphRM

graphRM <- delete_vertices(simplify(graphRM), degree(graphRM)==0)
```