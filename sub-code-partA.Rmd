---
title: "main-code2"
author: "Anshuman"
date: "1/19/2020"
output: pdf_document
---

```{r}
#number of taxa in the dataset
no_of_taxa = length(unique(Count_data$Taxon))

#define an empty list of adjacency matrices. (This is where the results are stored)
corr_mats2 = list()
MLES= matrix(0, 11, 8)
skew_meas= numeric(11)

#loop through each group
for(group in 1:10){
  
#generate a count matrix for current group
mat = matrix(0,0,length(unique(Count_data$Taxon)))

#start and end depth of the group
start = 7 + 0.5*group
end = 8 + 0.5*group

#extract counts in chunks of 30cm
for(i in seq(start,(end-0.2),0.2)){
  r = rep(0,no_of_taxa); names(r) = unique(Count_data$Taxon)
  for(j in seq(i,i+0.1,0.1)){
    idx = which(depth == j)
    r[Count_data$Taxon[idx]] = r[Count_data$Taxon[idx]] + Count_data$count[idx]
  }
  mat = rbind(mat,r)
}

#generate pseudo-counts by random bootstrap process, 1000 iterations
bootstrap = sapply(seq(1000), function(i){
  null = t(apply(mat,1,function(x) {
    #obtain rl string for the stratum
    rlstr = c()
    new_count = rep(0,ncol(mat)); names(new_count) = unique(Count_data$Taxon)
    for(count in x){
      if(count > 0){
        idx = which(x == count)
        rlstr = c(rlstr,rep(unique(Count_data$Taxon)[idx],count))
      }
    }
    #sanity check: see if any fossils exist at this level
    if(length(rlstr) > 0){
      #perform a sample with replacement
      rlstr = sample(rlstr,replace = T)
      counts = table(rlstr)
      new_count[names(counts)] = counts
      return(as.numeric(new_count))
    }
    else{
      return(x)
    }
  }))
  #obtain fossil co-abundance adjacency matrix based on pseudo counts
  cc = suppressWarnings(cor(null))
  
  #set diagnals of the matrix to 0
  diag(cc) = 0
  
  #return adjacency matrix flattened as a vector
  return(as.vector(cc))
})

corr_mats2[[group]] = matrix(rowMeans(bootstrap),nrow = no_of_taxa,ncol = no_of_taxa)

corr_mats2[[group]][!is.finite(corr_mats2[[group]])] <- 0
skew_meas[group] = skewness(corr_mats2[[group]][corr_mats2[[group]]!=0])

likSingle1 = function(parameters, x) dnorm(x, mean = parameters["mu1"],sd = parameters["sd1"])
llikAll1 = function(parameters, x){
  if (parameters["sd1"] < 0)
  {-Inf}
  else{sum(log(likSingle1(parameters, x)))}}

likSingle3 = function(parameters, x){dnorm(x, mean = parameters["mu1"], sd = parameters["sd1"]) * parameters["p1"] +dnorm(x, mean = parameters["mu2"], sd = parameters["sd2"]) *parameters["p2"] + dnorm(x, mean = parameters["mu3"],sd = parameters["sd3"]) * (1 - parameters["p1"] - parameters["p2"])}

llikAll3 = function(parameters, x){
  if (parameters["p1"] < 0 || parameters["p1"] > 1 || parameters["p2"] <0 || parameters["p2"] > 1 || parameters["p1"] + parameters["p2"] >1 || parameters["sd1"] < 0 || parameters["sd2"] < 0 || parameters["sd3"]<0){-Inf}
  else{sum(log(likSingle3(parameters, x)))}}

parameterInitialVals = c(mu1 = 0, sd1 = 0.5, mu2 = 1, sd2 = 0.6, mu3 = -0.5,sd3 = 0.1, p1 = 0.8, p2 = 0.1)
o = optim(par = parameterInitialVals, fn = llikAll3, x = corr_mats2[[group]][corr_mats2[[group]]!=0],control = list(fnscale = -1))

for (jj in 1:8) {
  MLES[group,jj]= o$par[jj]
}
 
}

plot(skew_meas)
```